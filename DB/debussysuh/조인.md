# 조인(join)
---
> 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- MySQL에서 JOIN 쿼리로 처리
- MongoDB에서 lookup 쿼리로 처리
- SQL JOIN 시각화 사이트 - https://sql-joins.leopard.in.ua/

**lookup - MongoDB**
MongoDB를 사용할 때 lookup은 되도록 사용하지 말아야 한다. MongoDB는 조인 연산에 대해 관계형 데이터베이스보다 성능이 떨어진다고 여러 벤치마크 테스트에서 알려져 있다.
따라서 여러 테이블을 조인하는 작업이 많을 경우 MongoDB보다는 관계형 데이터베이스를 써야 한다.


**조인의 종류**
두 테이블 간의 교집합이 있다고 할 때, 네 가지 조건이 있다. (왼쪽 테이블 A, 오른쪽 테이블 B)
- 내부 조인(inner join) : 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기된다.
- 왼쪽 조인(left outer join) : 왼쪽 테이블의 모든 행이 결과 테이블에 표기된다.
- 오른쪽 조인(right outer join) : 오른쪽 테이블의 모든 행이 결과 테이블에 표기된다.
- 합집합 조인(full outer join) : 두 개의 테이블을 기반으로 조인 조건에 만족하는 행까지 모두 표기된다.



## 1. 내부 조인
> 두 테이블 간에 교집합을 나타낸다.

```SQL
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```


## 2. 왼쪽 조인
> 오른쪽 테이블 B의 일치하는 부분의 레코드와 함께 **왼쪽 테이블 A를 기준**으로 완전한 레코드 집합을 생성
> 만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null값이 된다.

```SQL
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```



## 3. 오른쪽 조인
> 왼쪽 테이블 A에서 일치하는 부분의 레코드와 함께 **오른쪽 테이블 B를 기준**으로 완전한 레코드 집합을 생성
> 만약 테이블 A에 일치하는 항목이 없으면 해당 값은 null값이 된다.

```SQL
SELECT * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```


## 4. 합집합 조인(완전 내부 조인)
> 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성
> 이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력된다.

```SQL
SELECT * FROM TableA A
FULL OUTER JOIN JOIN TableB B ON
A.key = B.key
```






# 조인의 원리
----
조인의 종류는 이 원리를 기반으로 조인을 한다. 조인의 원리는 중첩 루프 조인, 정렬 병합 조인, 해시 조인이 있다.


## 1. 중첩 루프 조인(NLJ, Nested Loop Join)
> 중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법
> 랜덤 접근에 대한 비용이 많아 증가하므로 대용량의 테이블에서는 사용하지 않는다.

예를 들어 "t1, t2 테이블을 조인한다."라고 했을 때, 첫 번째 테이블에서 행을 한 번에 하나씩 읽고 그다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결괏값을 반환한다.

```
for each row in t1 matching reference key {
	for each row in t2 matching reference key {
		if row satisfies join conditions, send to client
	}
}
```

- 참고 : 블록 중첩 루프 조인(BNL, Block Nested Loop)
	- 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠서 블록 하나에 조인하는 방식




## 2. 정렬 병합 조인
> 각각의 테이블을 조인할 필드 기준으로 정렬하고, 정렬이 끝난 이후에 조인 작업을 수행하는 조인

조인할 때 쓸 적절한 인덱스가 없고, 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용한다.



## 3. 해시 조인
> 해시 테이블을 기반으로 조인하는 방법

- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적이다. (메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용이 발생한다.)
- 동등(=) 조인에서만 사용 가능

**MySQL의 경우 해시 조인의 과정**
- 빌드 단계
- 프로브 단계


### 빌드 단계
> 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- 데이터베이스 hash(countires.country_id) -> 인메모리 해시 테이블

예를 들어 persons와 countries라는 테이블을 조인한다고 했을 때 둘 중에 바이트가 더 작은 테이블을 기반으로 해서 테이블을 빌드한다.

또한, 조인에 사용되는 필드가 해시 테이블의 키로 사용된다.('countries.country_id')


### 프로브 단계
- 데이터베이스 hash(persons.country_id) -> 해시 테이블을 기반으로 일치하는 레코드 찾기 -> 결괏값
프로브 단계 동안 레코드 읽기를 시작하며, 각 레코드에서 'persons.country_id'에 일치하는 레코드를 찾아서 결괏값으로 반환한다.
이를 통해 각 테이블을 **한 번씩**만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋다.
- 사용 가능한 메모리양은 시스템 변수 join_buffer_size에 의해 제어되고, 런타임 시에 조정할 수 있다.