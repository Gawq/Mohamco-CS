# 인덱스
---
> 데이터를 빠르게 찾을 수 있는 하나의 장치
> 인덱스를 설정하여 테이블 안에 찾고자 하는 데이터를 빠르게 찾는다.

ex. 책 마지막 장의 찾아보기


## 1. B-트리
---
인덱스는 보통 B-트리 구조로 이루어져 있다. 이는 루트 노드, 리프 노드와 둘 사이에 있는 브랜치 노드로 나뉜다.

트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며, 브랜치 노드를 거쳐 리프 노드까지 내려온다. 이렇게 루트 노드부터 시작하여 마지막 리프 노드에 도달해서 데이터 포인터를 통해 결괏값을 반환하게 된다.


### 인덱스가 효율적인 이유와 대수확장성
---
**인덱스가 효율적인 이유**
효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 **대수확장성** 때문이다.

**대수확장성**
: 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.




## 2. 인덱스 만드는 방법
---
### MySQL
하나의 인덱스만 생성할 것이라면 클러스터형 인덱스가 성능이 좋다.

**클러스터형 인덱스**
- 테이블당 하나 설정
- primary key 옵션으로 기본키로 만들어 생성
- 기본키로 만들지 않고 unique not null 옵션을 붙여서 생성 가능

**세컨더리 인덱스**
- 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
- create index . . . 명령어 기반으로 만들어 생성 가능
- 예를 들어 age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요하다. 그러나 age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용해야 한다.


### MongoDB
도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다.
세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있다.



## 3. 인덱스 최적화 기법
---
### 인덱스는 비용이다
먼저 인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트 -> 컬렉션 순으로 하기 때문이며, 관련 읽기 비용이 들게 된다.
또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다. 마치 책의 본문이 수정되었을 때 목차나 찾아보기도 수정해야 하듯 말이다. 이때 B-트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.

그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다. 또한, 컬렉션에서 가져와야 하는 양이 많을 수록 인덱스를 사용하는 것은 비효율적이다.



### 항상 테스팅하라
인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그래서 항상 테스팅하는 것이 중요하다.
explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.

- MySQL에서 테스팅하는 코드
```SQL
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```



### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다.
같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다.

1. 어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있다면, 제일 먼저 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면, 그다음 인덱스로 설정한다.
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓴느 필드라면, 나중에 인덱스를 설정한다.
4. 유니크한 값의 정도를 카디널리티라고 한다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다.
	- 예를 들어 age와 email이 있다고 할 때, 어떤 것이 더 높을까? 당연히 email이다. 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야 하는 것이다.





## + 인덱스를 매 필드마다 설정하는 것이 좋을까?
---
먼저 인덱스는 두 번 탐색을 강요한다. 인덱스 리스트, 그다음 컬렉션 이렇게 두 번을 탐색하기 때문이며 읽기 관련 비용이 더 들게 된다. 그렇기 때문에 매 필드마다 설정하는 것은 고찰해봐야 한다.

또한, 테이블이 수정되면 인덱스도 수정되어야 한다. 책의 본문이 수정되면 목차나 찾아보기도 수정해야 하듯 말이다. 그리고 인덱스를 수정하는 것은 a=1을 a=2처럼 값만 수정하는 것보다 쉽지 않다. B-트리 구조를 사용하기 때문에 트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 분산시켜서 효율적으로 조회할 수 있도록 구축하는 비용도 든다.

그렇기 때문에 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다. 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.