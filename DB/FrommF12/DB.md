[데이터베이스 기본](#데이터베이스-기본)  
엔터티, 릴레이션, 속성, 차수, 도메인   
숫자타입, 필드타입, 문자타입  
관계, 키, 외래키  

[ERD와 정규화](#ERD와-정규화)  
함수 종속성, 정규화  

[트랜잭션과 무결성](#트랜잭션과-무결성)  
트랜잭션, ACID, isolation 격리 수준에 따른 문제, 무결성


## 데이터베이스 기본
데이터베이스는 일정한 규칙, 규약을 통해 구조화되어 저장되는 데이터의 모음이다  

데이터베이스를 제어, 관리하는 통합 시스템을 DBMS라고 한다  

데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다  

또한 데이터베이스는 실시간 접근과 동시 공유가 가능하다  

구조는 다음과 같다  

응용 프로그램  
ㅡㅡㅡㅡㅡㅡㅡ  
DBMS  
ㅡㅡㅡㅡㅡㅡㅡ  
데이터베이스  

### 엔터티

엔터티는 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사이다  

하나의 엔터티에는 여러 개의 속성을 가지며 서비스의 요구 사항에 맞춰 속성이 정해진다  

**약한 엔터티와 강한 엔터티**

A가 B의 존재 여부에 따라 종속적이라면 A는 약한 엔터티이고, B는 강한 엔터티가 된다  

### 릴레이션 (테이블, 컬렉션)

데이터베이스에서 정보를 구분하여 저장하는 기본 단위이다  

엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리하다  

릴레이션 : 엔터티에 관한 데이터를 보관하는 단위  

RDB에서는 테이블, NoSQL DB에서는 컬렉션이라고 한다  

### 속성

릴레이션 스키마는 릴레이션에 어떤 정보가 담길지를 정의한다  

각 열을 속성(attribute)이라고 한다  

속성에는 각각의 이름이 있으며 그 이름을 보고 어떤 정보가 담기는 지 알 수 있다  

서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔터티의 속성이 된다  

### 차수

릴레이션에 들어있는 속성의 수를 나타낸다  

유효한 릴레이션의 최소 차수는 1이다  

### 도메인

속성들이 가질 수 있는 값들의 집합이다  

성별(속성) : 도메인 = {남, 여 }  

### 헷갈리는 용어 정리

열(column) == 속성 == 필드  

행(row) == 튜플 == 레코드  

릴레이션 인스턴스 = 릴레이션 스키마에 실제로 저장된 데이터의 집합 (필드, 레코드의 집합)  

카디날리티 : 릴레이션 튜플의 개수, 차수와 다르게 카디날리티 0을 가질 수 있다  

### 필드 타입

**숫자 타입** : TINYINT(1), SMALLINT(2), MEDIUMINT(3), INT(4), BIGINT(8)  

**날짜 타입** : DATE, DATETIME, TIMESTAMP  

- DATE (3)  
날짜 부분은 있지만 시간 부분이 없다  
1000-01-01 ~ 9999-12-31

- DTAETIME (8)  
날짜 및 시간 부분을 모두 포함한다  
1000-01-01 00:00:00 ~ 9999-12-31 23:59:59

- TIMESTAMP (4)   
날짜 및 시간 부분을 모두 포함한다  
1970-01-01 00:00:01 ~ 2038-01-19 03:14:07  

**문자 타입** : CHAR, VARCHAR, TEXT, BLOB, ENUM, SET  

- CHAR, VARCHAR  
지정된 길이의 글자를 저장하는 타입이다  

CHAR는 테이블을 생성할 때 선언한 길이로 고정되며 길이는 0에서 255 사이의 값을 가진다  

레코드를 저장할 때 무조건 선언한 길이 값으로 고정해서 저장된다  

VARCHAR는 가변 길이 문자열로 0에서 65,535 사이의 값을 지정할 수 있다  

입력된 데이터에 따라 용량을 가변시켜 저장한다  

10글자의 문자를 저장할 경우 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장하게 된다  

- TEXT, BLOB
큰 데이터를 저장할때 쓰는 타입이다  

TEXT는 큰 문자열 저장에 쓰이며 주로 게시판의 본문을 저장할 때 쓴다  

BLOB은 이미지, 동영상 등 큰 데이터 저장에 쓴다  

보통은 서버에 파일을 올리고 파일에 관한 경로를 VARCHAR로 저장한다  

- ENUM, SET
문자열을 열거한 타입이다  

ENUM은 ENUM("small", "medium", "large") 형태로 쓰이며 최대 65,535개의 요소들을 저장할 수 있다  

이 중에서 단일 선택만 가능하다 

ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다  

SET은 ENUM과 비슷하지만 여러 개의 데이터를 선택할 수 있고 비트 단위의 연산을 할 수 있다

그리고 최대 64개의 요소만 저장할 수 있다  

### 관계

데이터베이스의 테이블의 관계는 다음과 같다 

1:1 관계, 1:N 관계, N:M 관계  

N:M 관계는 테이블 두 개를 직접적으로 연결해서 구축하지 않고 1:N, 1:M의 관계를 갖는 테이블 두 개로 나눠서 설정한다  

### 키 

슈퍼키 : 레코드를 식별할 수 있는 하나, 하나 이상 속성들의 집합  

후보키 : 슈퍼키 중 최소한의 속성들의 집합(유일성 + 최소성)  

기본키 : 후보키 중 1개만 기본키로 지정할 수 있다 (유일성 + 최소성)
NULL값과 중복된 값은 절대 가질 수 없으며(개체 무결성 제약조건) 자연키 또는 인조키 중에 골라 설정한다  

대체키 : 후보키가 두 개 이상일 경우 기본키로 지정되지 못하고 남은 후보키  

자연키 : 주민등록번호, 이메일, 휴대전화번호 등을 말하며 변할 수 있는 속성이 있다  

인조키 : 인위적으로 만든 변할 수 없는 키  (보통 기본키는 인조키로 설정한다)  

### 외래키

Foreign Key, FK라고 하며 다른 테이블의 기본키를 참조하여 테이블간의 관계를 연결하는 것이다  

외래키는 중복을 허용한다  

- 참조 무결성 제약조건
참조할 수 없는 외래키 값을 가질 수 없다  

외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다  

## ERD와 정규화  

**ERD**  

ERD (Entity Relationship Diagram)는 엔터티 간의 관계를 정의한 것이다  

시스템의 요구 사항을 기반으로 작성되며 ERD를 기반으로 데이터베이스를 구축한다  

관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용하지만 비정형 데이터를 충분히 표편할 수 없다  

비정형 데이터 : 비구조화 데이터, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보  

**정규화**  

릴레이션 간의 잘못된 관계로 인해 데이터베이스 이상 현상이 일어나 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정이다  

데이터베이스 이상 현상 : 불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 할 때 발생할 수 있는 부작용  

- 삽입 이상
특정 데이터가 존재하지 않아 중요한 데이터를 데이터베이스에 삽입할 수 없는 현상  

데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 현상   

- 수정 이상  
테이블의 특정 데이터를 수정했는데, 정상적으로 변경되지 않은 현상 또는 너무 많은 행을 수정하는 현상  

중복 튜플 중 이부만 변경하여 데이터가 불일치하는 현상  

- 삭제 이상
특정 정보를 삭제하면, 원치 않는 정보도 삭제되는 현상  

<br>

**함수 종속성**  

함수 종속이란 데이터베이스의 릴레이션에서 두 개의 속성 집합 간 제약의 일종이다  

릴레이션 R의 X와 Y를 속성 집합의 부분 집합이라고 했을 때 각각의 X 값에 대해 Y 값이 하나만 연관되어 있을 때 X -> Y라고 표기하며 Y는 X에 대해 함수 종속이라고 한다  

이 때 속성 집합 X를 결정자라고 하고, Y는 종속자라고 한다  

**예시**

```
테이블  
회사

필드  
사원번호 사원아이디 포지션 주언어  

레코드
id1, userA, 백엔드, Java  

id2, userB, 프론트, React  

후보키 : 사원번호, 사원아이디

기본키 : 결정자 (사원번호, 사원아이디)  

속성 : 종속자 (포지션, 주언어)  
```

- 완전 함수 종속  

종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우  

각각의 결정자 X 값은 하나의 종속자 Y와 연관을 갖는다  

기본키(id1, userA) -> 백엔드  

- 부분 함수 종속  

릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을 경우 기본키를 구성하는 속성 중 일부만 종속된 경우  

기본키(id1) -> 종속자(Java)

- 이행 함수 종속  

릴레이션에서 X,Y,Z라는 3개의 속성이 있을 때 X-Y, Y-Z 이란 종속 관계가 있을 경우, X->Z가 성립될 때 이행적 함수 종속이라고 한다  

X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우, 집합 Z가 집합 X에 이행적으로 함수 종속되었다고 한다  

- 결정자 함수 종속  

함수 종속의 결정자가 후보키가 아닌 경우  

종속자(Java) -> 결정자(userA)  

<br>

**정규화 과정**

정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 정규화된 정도는 정규형(NF, Normal Form)으로 표현한다  

기본 정규형 : 제1정규형(1NF), 제2정규형(2NF), 제3정규형(3NF)  

보이스-코드 정규형(BCNF)  

고급 정규형 : 4NF, 5NF, 6NF  

데이터 웨어하우스 디자인을 위한 관점 모델링과 같은 일부 모델링 규칙에서는 예외적으로 비 정규화된 디자인을 추천한다  

즉 대규모 부분에서의 디자인은 3NF가 아니다  

[위키백과](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94)

<br>

**정규화 원칙**

자료의 중복성 감소, 독립적인 관계는 별개의 릴레이션으로 표현, 각각의 릴레이션은 독립적으로 표현이 가능해야 한다  

**제1정규형**

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 한다  

릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지면 안된다  

id1, userA, 프론트, 백엔드, Java -> id1, userA, 백엔드, Java  

**제2정규형**  

릴레이션이 제1정규형이며, 부분 함수의 종속성을 제거한 형태를 말한다  

부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다  

결정자 X의 값이 하나의 Y값과 연관되야 한다  

제1정규형 (부분 함수 종속성)  
```
사원번호 사원아이디 포지션 언어

id1, userA, 백엔드, Java  
id1, userA, 프론트, JS  
id2, userB, 프론트, TS     
id2, userB, 백엔드, Kotlin    
```

제2정규형 (완전 함수 종속 만족)  
```
테이블 1
id1, userA
id2, userB

테이블 2
userA, 백엔드, Java
userB, 프론트, React
```
완전 종속된 테이블1 릴레이션과 사원아이디, 포지션에 따른 주언어 릴레이션으로 분리된 것을 볼 수 있다(테이블 예시가 이상함)  

이 때 주의할 점은 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되야 한다  

**제3정규형**

제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태를 말한다  

X->Y  
Y->Z  
X->Z 일 때 이행 함수 종속이라고 한다  

제2정규형 (이행 함수 종속성)  
```
유저id 등급 할인율  

홍철 플래티넘 30%  
범수 다이아 50%  
가영 마스터 70%
```

제3정규형 (이행 함수 종속성 제거)  
```
유저id 등급  

홍철 플래티넘
범수 다이아  
가영 마스터  

등급 할인율  

플래티넘 30%  
다이아 50%  
마스터 70%  
```
**보이스-코드 정규형**  

제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말한다  

제3정규형 (결정자 함수 종속성)
```
학번 수강명 강사

12010 코딩테스트 큰돌  
12010 MEVN 재엽  
```

릴레이션의 후보키는 {학번, 수강명} 또는 {학번, 강사}가 후보키가 된다  

위의 릴레이션은 두 가지 문제를 갖고 있다  

1. 결정자 함수 종속을 갖게 된다 (후보키가 아닌 강사 이름으로 수강명을 알 수 있다. 종속자 -> 결정자)
2. 새로운 강의(Java, 작은돌)가 생겨서 삽입한다고 했을 때 학번이 NULL이 되므로 삽입 이상이 발생한다  

BCNF 정규형 (결정자 함수 종속성 제거)  
```
학번 강사  

12010 큰돌  
12010 재엽  

수강명 강사  

코딩테스트 큰돌  
MEVN 재엽  
Java 작은돌  
```

## 트랜잭션과 무결성

트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다  

데이터베이스에 접근하는 방법은 쿼리이므로, 여러 개의 쿼리들을 하나로 묶는 단위를 말한다  

ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다  

**원자성 atomicity** 

all or nothing

트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다  

중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다  

트랜잭션 단위로 여러 로직을 묶을 때 외부 API를 호출하는 것이 있으면 안된다  

만약 있다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하고, 트랜잭션 전파를 신경 써서 관리해야 한다  

**일관성 consistency**  

허용된 방식으로만 데이터를 변경해야 하는 것을 의미한다  

트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다  

무결성 제약 조건을 위반하는 트랜잭션이 있다면 트랜잭션은 중단된다 

(무결성 제약 조건이 모든 계좌에 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단)  

**격리성 isolation** (독립성, 고립성)  

트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 말한다  

트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다  

복수의 병렬 트랜잭션은 서로 격리되어 block/sync로 실행되는 것처럼 작동되야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 한다  

격리성은 가장 유연성 있는 제약 조건으로 여러 개의 격리 수준으로 나누어 격리성을 보장한다  

격리수준은 다음과 같이 있으며 위로 갈수록 동시성이 강해지는 대신 격리성이 약해진다

READ_UNCOMMITED  

READ_COMMITTED  

REEPEAABLE_READ  

SERIALIZABLE  

- SERIALIZABLE 

가장 높은 격리성을 가지는 수준으로, 트랜잭션을 순차적으로 진행시키는 것을 말한다  

여러 트랜잭션이 동시에 같은 행에 접근할 수 없다  

해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 일어난다면 기다려야 한다  

교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준이다  

- REPEATABLE_READ  

하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다  

따라서 이후에 추가된 행이 발견 될 수 있다  

- READ_COMMITTED  

가장 많이 사용되는 격리 수준으로 MySQL 8.0, PostgreSQL, SQL Server, Orabcle에서 기본값으로 설정되어 있다  

READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다  

즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다  

하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다  

트랜잭션 A가 수정한 행을 트랜잭션 B가 수정하여 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다  

- READ_UNCOMMITTED  

가장 낮은 격리 수준으로 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다  

데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적이나, 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 어림잡아 집계하는 데는 사용하면 좋다  

**격리 수준에 따라 발생하는 현상**  

- 팬텀 리드  

한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우 (조회 결과)   

트랜잭션 A가 조회 쿼리(레코드 3개 예상) -> 트랜잭션 B가 삽입 쿼리 (1개) -> 트랜잭션 A 조회 쿼리 (4개) - 동일한 테이블 기준  

- 반복 가능하지 않은 조회  

한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데 그 값이 다른 경우  

트랜잭션 A가 조회 -> 트랜잭션 B가 A의 행을 수정 -> 트랜잭션 A가 다시 조회 (데이터 변경)  

- 더티 리드  

한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 때 발생한다  

트랜잭션 A 수정, 커밋하지 않은 상태 -> 트랜잭션 B 조회

REPEATABLE_READ : 팬텀리드  

READ_COMMITTED : 팬텀리드, 반복 가능하지 않은 조회  

READ_UNCOMMITTED : 팬텀리드, 반복 가능하지 않은 조회, 더티 리드  

**지속성 durability**  

성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다  

데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 한다  

이를 위해 데이터베이스는 체크섬, 저널링, 롤백 등의 기능을 제공한다  

모든 트랜잭션은 로그로 남고 시스템 장애 발생 전으로 되돌릴 수 있다  

트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다  

체크섬 : 중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 방법  

저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경사항을 반영하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것  

### 무결성  

데이터베이스의 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다  

무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 지에 대한 신뢰가 생긴다  

**개체 무결성**  

기본키로 선택된 필드는 NULL값과 중복값을 허용하지 않는다  

**참조 무결성**  
서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다  

참조할 수 없는 외래키 값을 가질 수 없다  

외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다  

**고유 무결성**  

특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다  

**NULL 무결성**  

특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다
