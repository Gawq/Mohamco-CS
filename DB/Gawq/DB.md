### 데이터베이스(DB, DataBase)란?
> 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음

해당 데이터베이스를 제어, 관리하는 통합 시스템을 DBMS(DataBase Management System)라고 하며, 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다.

### 엔티티(entity)란?
>사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사

**약한 엔티티와 강한 엔티티**
예를 들어 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이라면 A는 약한 엔티티이고 B는 강한 엔티티가 된다.

### 릴레이션(relation)란?
>데이터베이스에서 정보를 구분하여 저장하는 기본 단위

엔티티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리한다.

릴레이션은 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는 '컬렉션'이라고 한다.

**테이블과 컬렉션**
데이터 베이스의 종류는 크게 관계형 데이터베이스와 NoSQL 데이터베이스로 나눌 수 있다. 이 중 대표적인 관계형 데이터베이스인 MySQL과 대표적인 NoSQL 데이터베이스인 MongoDB를 예로 들면, MySQL의 구조는 레코드-테이블-데이터베이스로 이루어져 있고 MongoDB 데이터베이스의 구조는 도큐먼트-컬렉션-데이터베이스로 이루어져 있다.

### 속성(attribute)이란?
>릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

에를 들어 '차'라는 엔티티의 속성을 뽑아보면, 차 넘버, 바퀴 수, 차 색깔, 차종 등이 있다. 이 중에서 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔티티의 속성이 된다.

### 도메인(domain)이란?
>릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

예를 들어 성별이라는 속성이 있다면 이 속성이 가질 수 있는 값은 {남, 여}라는 집합이 된다.

### 필드와 레코드
앞에서 설명한 것들을 바탕으로 데이터베이스에서 필드와 레코드로 구성된 테이블을 만들 수 있다.
![](https://velog.velcdn.com/images/cnj9912/post/c16b36f4-fe86-4a9c-905a-326b1fdf9bc4/image.png)

고객이란 엔티티는 고객코드, 이름, 전화번호 등의 필드를 가진다. 그리고 이 테이블에 쌓이는 행(row) 단위의 데이터를 레코드라고 한다. 또한 레코드를 튜플이라고도 한다.

### 관계
데이터베이스에 테이블은 하나만 있는 것이 아니다. 여러 개의 테이블이 있고 이러한 테이블은 서로의 관계가 정의되어 있다.
![](https://velog.velcdn.com/images/cnj9912/post/3edc6d9e-66cf-4ce2-9ece-ae2a48fb24f8/image.png)

**1:1 관계**
1:1 관계는 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 준다.

예를 들어, 일반적으로 컴퓨터 1대에 1개의 마우스가 있으므로 1:1 관계라고 할 수 있다.

**1:N 관계**
두 개의 서로 다른 타입의 두 개체들 A와 B가 있을 때, A 개체가 B 개체 여러 개와 연결될 수 있지만 B 개체는 1개의 A 개체만 연결될 수 있는 관계이다.

예를 들어, 컴퓨터는 1개 이상의 USB 드라이브를 인식할 수 있지만 USB 드라이브는 1대의 컴퓨터랑만 연결할 수 있으므로 컴퓨터와 USB 드라이브는 1:N 관계라 할 수 있다.

**N:M 관계**
학생과 강의의 관계를 정의하면, 학생도 강의를 많이 들을 수 있고 강의도 여러 명의 학생을 포함할 수 있기 때문에 N:M 관계가 된다.

### 키
테이블 간의 관계를 조금 더 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 기본키, 외래키, 후보키, 슈퍼키, 대체키가 있다.
![](https://velog.velcdn.com/images/cnj9912/post/e081c051-4589-465b-9573-70f3e73c7ac9/image.png)

슈퍼키는 유일성이 있고 그 안에 포함된 후보키는 최소성까지 갖춘 키이다. 후보키 중에서 기본키로 선택되지 못한 키는 대체키가 된다. 유일성은 중복되는 값은 없으며, 최소성은 필드를 조합하지 않고 최소 필드만 써서 키를 형성할 수 있는 것을 말한다.

**기본키**
기본키(Primary Key)는 줄여서 PK 또는 프라이머리키라고 많이 부르며, 유일성과 최소성을 만족하는 키이다.

이는 테이블의 데이터 중 고유하게 존재하는 속성이며 기본키에 해당하는 데이터는 중복되어서는 안된다.

**외래키**
외래키(Foreign Key)는 FK라고도 하며, 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는 데 사용한다.

외래키는 중복되어도 상관없다.

**후보키**
후보키(candidate key)는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키이다.

**대체키**
대체키(alternate key)는 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.

**슈퍼키**
슈퍼키(super key)는 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키이다.

### ERD(Entity Relationship Diagram)란?
>데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하며, 릴레이션 간의 관계들을 정의한 것

만약 서비스를 구축한다면 가장 먼저 신경 써야 할 부분이며 이 부분을 신경 쓰지 않고 서비스를 구축한다면 단단하지 않은 골조로 건물을 짓는 것이나 다름없다.

### ERD의 중요성
ERD는 시스템의 요구 사항을 기반으로 작성되며 이 ERD를 기반으로 데이터베이스를 구축한다. 데이터 베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 담당하기도 한다.

하지만 ERD는 관계형 구조로 표혈할 수 있는 데이터를 구성하는 데 유용할 수 있지만 비정형 데이터를 충분히 표현할 수 없다는 단점이 있다.
>**비정형 데이터**
비구조화 데이터를 말하며, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보를 말한다.

### 정규화 과정
정규화 과정은 릴레이션 간의 잘못된 종속 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정이다.

데이터베이스 이상 현상이란 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안되어서 삽입하기 어려운 현상을 말한다.

정규화 과정은 정규형 원칙을 기반으로 정규형을 만들어가는 과정이며, 정규화된 정도는 정규형(NF, Normal Form)으로 표현한다. 기본 정규형인 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형이 있고 고급 정규형인 제4정규형, 제5정규형이 있다. 이 중 기본 정규형인 제1정규형, 제2정규형, 제3정규형, 보이스/코드 정규형을 알아보겠다.

**정규형 원칙**
정규형의 원칙이란 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 하고, 자료의 중복성은 감소해야 하고, 독립적인 관계는 별개의 릴레이션으로 표현해야 하며, 각각의 릴레이션은 독립적인 표현이 가능해야 하는 것을 말한다.

**제1정규형**
릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 한다. 릴레이션의 속성 값 중에서 한 개의 기본키에 두해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 된다. 만약에 반복 집합이 있다면 제거해야 한다.
![](https://velog.velcdn.com/images/cnj9912/post/aed0cfdc-eccb-4e24-bbe1-f2be459785c9/image.png)

예를 들어 위처럼 릴레이션이 이루어져 있다면, 제1 정규형을 만족하지 못한다. 학번이 100인 학생의 과목 번호와 성적이 2개로 이루어져 있기 때문이다. 따라서 제1 정규형이 되려면 다음과 같이 속성 값을 분리해주어야 한다.
![](https://velog.velcdn.com/images/cnj9912/post/75a16d5b-ead9-40b7-84c3-0698233c3844/image.png)

**제2정규형**
릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태를 말한다.

부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다.
![](https://velog.velcdn.com/images/cnj9912/post/632bd8c5-5bbe-4250-8d60-660d70e7ab2a/image.png)

위 그림처럼 각 속성들이 모두 완전 함수 종속이 되도록 릴레이션을 분리시켜준다. 따라서 아래와 같이 릴레이션이 형성된다.

![](https://velog.velcdn.com/images/cnj9912/post/9006b4f1-ede4-4096-9e3d-18cf03b729b6/image.png)

이 때 주의할 점은 릴레이션을 분해할 때 동등한 릴레이션을 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 한다는 것이다.

**제3정규형**
제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않는 상태를 말한다.

>**이행적 함수 종속**
A -> B와 B -> C가 존재하면 논리적으로 A -> C가 성립하는데, 이때 집합 C가 집합 A에 이행적으로 함수 종속이 되었다고 한다.

![](https://velog.velcdn.com/images/cnj9912/post/6c2c94d6-e340-4299-ad9f-0be41a0ca2ea/image.png)

이렇게 이행적 함수 종속 관계에 있는 속성을 분리한다. 테이블로 나타내면 아래와 같다.

![](https://velog.velcdn.com/images/cnj9912/post/608eee97-9762-4f49-ac1b-78c579df0fc1/image.png)

**보이스/코드 정규형**
보이스/코드 정규형(BCNF)은 제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태를 말한다.
>**결정자**
함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소, 'X -> Y'일 때 X는 결정자, Y는 종속자이다.

아래와 같은 제3 정규형을 만족하는 릴레이션이 있다고 가정하자. 한 교수당 하나의 수업만 맡는다고 가정한다.

![](https://velog.velcdn.com/images/cnj9912/post/499ecc11-9c94-48fc-92b4-9bb2b268d4d2/image.png)

모든 결정자는 항상 후보키가 되도록 릴레이션을 분해해주면 강한 제3 정규형, 즉 BCNF를 만족하게 된다.
![](https://velog.velcdn.com/images/cnj9912/post/0d251558-4cb8-4e12-992b-d6b1c0a65e58/image.png)

## 트랜잭션이란?
> 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위

데이터베이스에 접근하는 방법은 쿼리이므로, 즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다. 이에 대한 특징은 원자성, 일관성, 독립성, 지속성이 있으며 이를 한꺼번에 ACID 특징이라고 한다.

### 원자성
"all or nothing"

원자성(atomicity)은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다. 예를 들어 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장하는 것을 말한다.

또한, 트랜잭션 단위로 여러 로직들을 묶을 때 외부 API를 호출하는 것이 있으면 안 된다. 만약 있다면 롤백이 일어났을 때 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하고 트랜잭션 전파를 신경 써서 관리해야 한다.

**커밋과 롤백**
커밋(commit)은 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어이다. 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장되는 것을 말한다. "커밋이 수행되었다."를 "하나의 트랜잭션이 성공적으로 수행되었다."라고도 말한다.

update, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행되고 이후에 데이터베이스에 영구 저장된다.

하지만 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 한다면 어떻게 해야 할까?

이때 사용하는 것이 롤백이다. 롤백이란 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)을 말한다.

이러한 커밋과 롤백 덕에 데이터의 무결성이 보장된다. 또한, 데이터 변경 전에 변경 사항을 쉽게 확인할 수 있고 해당 작업을 그룹화할 수 있다.

**트랜잭션 전파**
트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다. 하지만 이를 매번 넘겨주기가 어렵기도 하고 귀찮다. 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랙잭션 전파라고 한다.

```java
@Service
@Transactional(readOnly = true)
public class MemberService {
	private final MemberRepository memberRepository;
    
    public MemberService(MemberRepository memberRepository) {
    	this.memberRepository = memberRepository;
    }
}
```

앞의 코드처럼 Spring 프레임워크에서는 `@Transactional` 애너테이션을 통해 여러 쿼리 관련 코드들을 하나의 트랜잭션으로 처리한다.

### 일관성
일관성(consistency)은 '허용된 방식'으로만 데이터를 변경해야 하는 것을 의미한다. 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 한다. 예를 들어 홍철이는 1000만 원이 있고 범석이는 0원이 있다고 치자. 범석이가 나한테 500만 원을 입금할 수 있을까? 불가능하다. 0원으로부터 500만 원이 나오는 것은 불가능하다.

### 격리성
격리성(isolation)은 트랜잭션 수행 시 서로 끼어들지 못하는 것을 말한다. 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 하고, 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 한다.

격리성은 여러 개의 격리 수준으로 나뉘어 격리성을 보장한다.
![](https://velog.velcdn.com/images/cnj9912/post/b3629745-2f4d-4475-8d04-2d774c7d4e51/image.png)

격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED가 있으며 위로 갈수록 동시성이 강해지지만 격리성은 약해지고, 아래로 갈수록 동시성은 약해지고 격리서은 강해진다.

REPEATABLE_READ는 팬텀 리드, READ_COMMITTED는 팬텀 리드, 반복 가능하지 않은 조회가 발생하며, READ_UNCOMMITTED는 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 발생할 수도 있다.

**격리 수준에 따라 발생하는 현상**

- 팬텀 리드
  팬텀리드(phantom read)는 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.
  예를 들어 사용자 A가 회원 테이블에서 age가 12 이상인 회원들을 조회하는 쿼리를 보낸다고 했을 때, 이 결과로 세 개의 테이블이 조회된다고 해보자. 그 다음 사용자 B가 age가 15인 회원 레코드를 삽입한다. 그러면 그다음 세 개가 아닌 네 개의 테이블이 조회되는 것이다.

- 반복 가능하지 않은 조회
  반복 가능하지 않은 조회(non-repeatable read)는 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킨다. 예를 들어 사용자 A가 큰돌의 보석 개수가 100개라는 값을 가진 데이터였는데, 그 이후 사용자 B가 그 값을 1로 변경해서 커밋했다고 하면 사용자 A는 100이 아닌 1을 읽게 된다.

- 더티 리드
  더티 리드(dirty read)는 반복 가능하지 않은 조회와 유사하며 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생한다. 예를 들어 사용자 A가 큰돌의 보석 개수 100을 1로 변경한 내용이 '커밋되지 않은' 상태라도 그 이후 사용자 B가 조회한 결과가 1로 나오는 경우를 말한다.

**격리 수준**

- SERIALIZABLE
  SERIALIZABLE은 말 그대로 트랜잭션을 순차적으로 진행시키는 것을 말한다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다. 이 수준은 매우 엄격한 수준으로 해당 행에 대해 격리시키고, 이후 트랜잭션이 이 행에 대해 일어난다면 기다려야 한다. 그렇기 때문에 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준이다.

- REPEATABLE_READ
  REPEATABLE_READ는 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 ㅜㅊ가하는 것은 막지 않는다. 따라서 이후에 추가된 행이 발견될 수도 있다.

- READ_COMMITTED
  READ_COMMITTED는 가장 많이 사용되는 격리 수준이며 MySQL8.0, PostgreSQL, SQL Server, 오라클에서 기본값으로 설정되어 있다. READ_UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉, 커밋 완료된 데이터에 대해서만 조회를 허용한다.
  하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다. 예를 들어 트랜잭션 A가 수정한 행을 트랜잭션 B가 수정할 수도 있다. 이 때문에 트랜잭션 A가 같은 행을 다시 읽을 때 다른 내용이 발견될 수도 있다.

- READ_UNCOMMITTED
  READ_UNCOMMITTED는 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠르다. 이는 데이터 무결서을 위해 되도록이면 사용하지 않는 것이 이상적이나, 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데는 사용하면 좋다.

### 지속성
지속성(durability)은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다. 이는 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻하며, 데이터 베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능을 제공한다.

> - **체크섬**
    중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법
- **저널링**
  파일 시스템 또는 시스템에 변경 사항을 반영(commit)하기 전에 로깅하는 것, 트랜잭션 등 변경 사항에 대한 로그를 남기는 것

## 무결성이란?
무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 말하며, 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생긴다. 무결성의 종류는 다음과 같다.

|이름|설명|
|:|:|
|개체 무결성|기본키로 선택된 필드는 빈 값을 허용하지 않는다.|
|참조 무결성|서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.|
|고유 무결성|특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.|
|NULL 무결성|특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건이다.|

## 관계형 데이터베이스
관계형 데이터베이스(RDBMS)는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며 SQL이라는 언어를 써서 조작한다. MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등이 있다. 참고로 관계형 데이터베이스의 경우 표준 SQL은 지키기는 하지만, 각각의 제품에 특화시킨 SQL을 사용한다. 예를 들어 오라클의 경우 PL/SQL이라고 하며 SQL Server에서는 T-SQL, MySQL은 SQL을 쓴다.

### MySQL
MySQL은 대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스이다.

C, C++로 만들어졌으며 MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공한다. 대용량 데이터베이스를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공하며 많은 서비스에서 사용한다.

MySQL의 스토리지 엔진 아키텍처는 다음과 같다.

![](https://velog.velcdn.com/images/cnj9912/post/36351d98-60bb-4bf7-aaa2-2252c58e348f/image.png)

데이터베이스의 심장과도 같은 역할을 하는 곳이 바로 스토리지 엔진인데, 모듈식 아키텍처로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점을 두고 있다. 스토리지 엔진 위에는 커넥터 API 및 서비스 계층을 통해 MySQL 데이터베이스와 쉽게 상호 작용할 수 있다.

또한, MySQL은 쿼리 캐시를 지원해서 입력된 쿼리 문에 대한 전체 결과 집합을 저장하기 때문에 사용자가 작성한 쿼리가 캐시에 있는 쿼리와 동일하면 서버는 단순히 구문 분석, 최적화 및 실행을 건너뛰고 캐시의 출력만 표시한다.

### PostgreSQL
PosrgreSQL은 MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술이다
![](https://velog.velcdn.com/images/cnj9912/post/44faf8a5-c2ab-44f7-b17e-034ce8130fd1/image.png)

디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징이다. 최대 테이블의 크기는 32TB이며 SQL뿐만 아니라 JSON을 이용해서 데이터에 접근할 수 있다. 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있다.

## NoSQL 데이터베이스
NoSQL(Not only SQL)이라는 슬로건에서 생겨난 데이터베이스이다. SQL을 사용하지 않는 데이터베이스를 말하며, 대표적을 MongoDB와 redis 등이 있다.

### MongoDB
![](https://velog.velcdn.com/images/cnj9912/post/3af1de7e-8fc0-4174-97c8-fca3d473aab9/image.png)

MongoDB는 JSON을 통해 데이터에 접근할 수 있고, Binary JSON 형태(BSON)로 데이터가 저장되며 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스다. 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고 고가용성과 샤딩, 레플리카셋을 지원한다. 또한, 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점을 봉니다.

또한, MongoDB는 도큐먼트가 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID가 생성된다.

![](https://velog.velcdn.com/images/cnj9912/post/e4b0d64d-e2da-48a3-ae26-9d1b1a74063c/image.png)


### redis
redis는 인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스이다.

![](https://velog.velcdn.com/images/cnj9912/post/041eee68-7fa8-42d7-b69f-cbb9e29780ec/image.png)

기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장할 수 있다. 이외에도 셋(set), 해시(hash) 등을 지원한다.

pub/sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스에 사용한다.