# 0. 인덱스

# 1. 인덱스의 필요성

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치다.
예를들어 책의 마지막장에 있는 찾아보기를 생각하면 된다. 찾고자 하는 데이터를 빠르게 찾을 수 있는 것이다.

# 2. B 트리

인덱스는 B-트리라는 자료 구조로 이루어져 있고 이는 루트 노드, 리프 노드, 브랜치 노드로 나뉜다.
E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아닌 E가 있을 법한 리프 노드로 들어가서 탐색한다.

# 3. 인덱스 만드는 방법

## MySQL

MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있다.
클러스터형 인덱스는 테이블 당 하나 설정, primary key 옵션으로 기본키를 만들면 생성 가능
기본키로 하지 않고 unique not null 옵션을 붙이면 만들 생성 가능.
세컨더리 인덱스는 create index.. 명령어를 기반으로 만들면 만들 수 있다. 하나의 인덱스만을 생성할 것이라면 클러스터형이 성능이 더 좋다.

세컨더리 인덱스 : 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때
클러스터 인덱스 : age라는 하나의 필드만으로 쿼리를 보낼 때

## MongoDB

자동으로 objectID가 형성되며 해당 키가 기본키로 된다.
세컨더리키도 부가적으로 설정해 기본키와 세컨더리키를 같이 쓰는 복합 인덱스가 가능하다.

# 4. 인덱스 최적화 기법

## 1. 인덱스는 비용이다

인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문에 읽기 비용이 든다.
또한 컬렉션이 수정되었을 때 인덱스도 수정되어야하고 트리의 높이를 균형있게 조절하는 비용, 데이터를 효율적으로 조회할 수 있는 분산 비용도 든다.
그렇기에 무작정 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 답이 아니다.또한 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.

## 2. 항상 테스팅하라

인덱스 최적화 기법은 서비스에 따라 달라진다. 그래서 항상 테스팅하는 것이 중요하다

## 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

1. 어떠한 값과 같음을 비교하는 ==, equal이라는 쿼리가 있으면 제일 먼저 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정한다.
3. 다중 값을출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
4. 유니크한 값의 정도를 카디널리티라고 하는데 이게 높은 순서를 기반으로 인덱스를 생성해야 한다.
