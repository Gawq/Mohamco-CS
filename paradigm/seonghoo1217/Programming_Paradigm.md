![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEjKha%2FbtqUeXDkUpM%2F54da0e07OWNO5ANhz5Vsu1%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEjKha%2FbtqUeXDkUpM%2F54da0e07OWNO5ANhz5Vsu1%2Fimg.png)

프로그래머에게 프로그래밍의 관점을 갖게 하고 코드를 어떻게 작성할 지 결정하는 역할을 하는 것이 프로그래밍 패러다임이다. 새로운 프로그래밍 패러다임을 통해서는 새로운 방식으로 생각하는 법을 배우게 되고, 이를 바탕으로 코드를 작성하게 된다.

프로그래밍 패러다임은 분류적으로는 크게 `**명령형**`과 `**선언형`** 프로그래밍 방법이 존재하며, 선언형은 다시 함수형이라는 하위 구조를 갖고 명령형은 객체지향과 절차지향언어로 구분된다.

- **프로그래밍 패러다임**
    - **명령형(Imperative)** : What보다 How의 관점
        - **객체지향(Object-Oriented)** : C++, Java , C#, Kotlin
        - **절차지향(Procedural)** : C, C++
    - **선언형(Declarative)** : How 보다 What의 관점
        - **함수형(Functional) :** 클로저, 하스켈, 리스프

### 명령형과 선언형 정의

명령형 프로그래밍과 선언형 프로그래밍의 개념은 그 이름에서 드러나듯 해당 로직을 처리하는 방식을 컴퓨터에게 **명령**하거나 무슨 일을 처리해야하는지 **선언**한다.

약간 애매모호한 말인것 같아 예시와 함께 설명을 덧붙여보자면, 내가 ‘붕어빵을 먹고싶다’라고 하였을때 **‘***집에서 나와 아파트 출입구 기준으로 오른쪽 방향 100M 직진후 붕어빵 가게에서 붕어빵을 구매한 뒤 먹으세요***’**라고 한다면 이는 명령형 프로그래밍이고 *‘붕어빵 가게를 소개시켜드릴까요?’* 라고한다면 선언형 프로그래밍이다.

좀더 간결히 설명하자면 명령형 프로그래밍은 무엇을 **어떻게** 할 것인가에 가깝고, 선언형 프로그래밍은 **무엇을** 할 것인가에 가깝다.

![https://velog.velcdn.com/images/dbworud/post/508f9fe9-0629-4808-917f-fe86cf861ce6/thumbnail.png](https://velog.velcdn.com/images/dbworud/post/508f9fe9-0629-4808-917f-fe86cf861ce6/thumbnail.png)

### 명령형과 선언형 특징

**명령형 프로그래밍**

- 목표를 달성하기까지의 flow가 자세히 드러나 있다.
- 알고리즘은 명시하되, 목표는 명시하지 않는다.
- How의 개념이 중요시되며, 코드적 관점에서 구현하는 방법이 무엇을 개발하느냐 보다 중요하다.

**선언형 프로그래밍**

- 필요한 것을 달성하는 과정 하나하나 기술하는 것 보다 필요한 것이 어떤 것인지 기술하는데 초점을 맞추어 서비스의 설계를 세워나가는 구조
- 목표를 명시하고, 알고리즘은 명시하지 않는다.
- 프로그램이 함수형 또는 논리형 프로그래밍 언어로 작성된 경우
- 장점 : 가독성과 재사용성이 높고 오류가 적다. 프로그램 동작을 변경하지 않고도 관련 값을 대체 할 수 있다

## 함수형 프로그래밍

- 성공적인 프로그래밍을 위해 부수 효과를 미워하고 조합성을 강조하는 프로그래밍 패러다임
    - *부수효과를 미워한다* -> **순수함수**를 만든다.
        - **순수함수** : 들어온 인자가 같으면 결과가 항상같은 함수
        - **부수효과** : 리턴값으로 결과를 만드는것 외에 들어온 인자를 직접 변경하는 등 외부에 영향을 주는것
- 선언형 프로그래밍 패러다임의 하나이며, **자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임**을 의미한다.
- `클로저,스칼라,하스켈` 등의 언어가 존재하며 최근 들어서 `자바스크립트, 코틀린, 파이썬` 등에도 최근버전의 함수형 프로그래밍 문법이 추가되었다.

### 순수함수

- 받은 인자외에 다른 외부의 상태에 영향을 끼치지 않고 리턴값 외에는 외부와의 소통이 이루어져 있지 않다.
- 순수함수로 함수형 프로그래밍을 할 경우 오류를 줄이고 안정성을 높인다.
- 순수함수는 평가 시점이 중요하지 않다.
  만약 순수함수가 아니라면 동일한 인자를 넣어도 다른 값이 나오는 경우 어떠한 시점에서 함수를 평가할지가 중요해진다.
  **하지만,** 순수함수는 정의적으로 동일한 인자로 동일한 결과가 나와야하기에 평가시점을 중요시하지 않는다.

**순수함수의 옳바른 예**

1. **항상 동일한 인자를 줄경우 동일한 결과를 리턴**

```java
private int pureFunction(int a, int b){
		return a+b;
}
```

```java
class Main{
	public static void main(String[] args) {
		int sum=pureFunction(5,10);
		System.out.println(15.equal(sum));//true
	}
}
```

1. **순수함수가 아닌 경우**

```java
int c=10; //값의 변화 유발

private int notPureFunction(int a,int b){
		return a+b+c;
} 

c=15;
```

위의 코드는 항상 동일한 인자가 들어가도 c값에 따라서 결괏값이 달라질수 있다.

```java
int c=20; //값의 변화를 유발한다.

private int notPureFunction(int a,int b){
		c=b;
		return a+b;
} 
```

### 고차함수

- 함수를 인자로 받을 수 있고, 함수의 형태로 리턴할 수 있는 함수이다.

### 함수형 프로그래밍 등장배경

명령형 프로그래밍을 기반으로 개발했던 개발자들은 개발하는 소프트웨어 크기가 커짐에 따라, 복잡하게 엉켜있는 스파게티 코드를 유지보수하는 것이 매우 힘들다는 것을 깨닫게 되었다.

그리고 이를 해결하기 위한 함수형 프로그래밍이라는 프로그래밍 패러다임을 고안하게 되었다. 함수형 프로그래밍은 거의 모든 것을 순수함수로 나누어 문제를 해결하는 기법으로, 작은 문제를 해결하기 위한 함수를 작성하여 **가독성을 높이고 유지보수를 용이하게** 해준다.

로버트 C.마틴의 저서인 클린코드에서 함수형 프로그래밍은 **대입문 없는 프로그래밍**이라고 정의한다.

### 함수형 프로그래밍 이해

함수형 프로그래밍은 앞서 말했듯, **대입문을 사용하지 않는 프로그래밍**이며, **작은 문제를 해결하기 위한 함수를 작성**한다고 하였다.

앞서 설명하였듯 함수형 프로그래밍은 무엇을(What)에 포커스를 두는 프로그래밍이라고 하였다. 그렇기 때문에 함수형 프로그래밍에서는 '**출력을 하는 함수**
'를 파라미터로 넘길 수 있으며, 이는 함수형 프로그래밍의 기본 원리 中 함수를 1급 시민(First-Class Citizen) 또는 1급 객체(First-Class Object)로 관리하는 특징 때문이다.

### 함수형 프로그래밍의 특징

> 부수 효과가 없는 순수함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.
>

중요 KeyWord: **부수효과, 순수함수, 1급 객체, 참조 투명성**

### **부수효과(Side Effect)**

---

여기서 부수효과(Side Effect)란 다음과 같은 변화 또는 변화가 발생하는 작업을 의미한다.

- 변수의 값이 변경됨
- 자료 구조를 제자리에서 수정함
- 객체의 필드값을 설정함
- 예외나 오류가 발생하며 실행이 중단됨
- 콘솔 또는 파일 I/O가 발생함

### **순수 함수(Pure Function)**

---

그리고 이러한 부수 효과(Side Effect)들을 제거한 함수들을 순수 함수(Pure Function)이라고 부르며, 함수형 프로그래밍에서 사용하는 함수는 이러한 순수 함수들이다.

- Memory or I/O의 관점에서 Side Effect가 없는 함수
- 함수의 실행이 외부에 영향을 끼치지 않는 함수

### **순수 함수(Pure Function)의 장점**

---

순수 함수(Pure Function)을 이용하면 얻을 수 있는 효과는 다음과 같다.

- 함수 자체가 독립적이며 Side-Effect가 없기 때문에 Thread에 안전성을 보장받을 수 있다.
- Thread에 안정성을 보장받아 병렬 처리를 동기화 없이 진행할 수 있다.

### **1급 객체(First-Class Object)**

---

1급 객체란 다음과 같은 것들이 가능한 객체를 의미한다.

- 변수나 데이터 구조 안에 담을 수 있다.
- 파라미터로 전달 할 수 있다.
- 반환값으로 사용할 수 있다.
- 할당에 사용된 이름과 무관하게 고유한 구별이 가능하다.

함수형 프로그래밍에서 함수는 1급 객체로 취급받기 때문에 위의 예제에서 본 것 처럼 함수를 파라미터로 넘기는 등의 작업이 가능한 것이다. 또한 우리가 일반적으로 알고 개발했던 함수들은 함수형 프로그래밍에서 정의하는 순수 함수들과는 다르다는 것을 인지해야 한다.

### **참조 투명성(Referential Transparency)**

---

참조 투명성(Referential Transparency)이란 다음과 같다.

- 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다.
- 참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다.(Immutable Data)

결론적으로 명령형 프로그래밍과 함수형 프로그래밍의 차이로는 **부수효과가 발생하는지에 차이가 존재한다**.

### 함수형 프로그래밍 예제 코드

단어 모음에 대하여 다음과 같은 요구사항을 지니고 있는 코드가 존재한다.

1. 단어의 크기가 2 이상인 경우를 필터링한다.
2. 모든 단어를 대문자로 변환한다.
3. 모든 단어를 앞글자만 잘라내어 변환한다.
4. 모든 단어를 스페이스로 구분한 하나의 문자열로 합친다.

```java
public class WordProcessTest {

    private final List<String> words = Arrays.asList("TONY", "a", "hULK", "B", "america", "X", "nebula", "Korea");

    @Test
    void wordProcessTest() {
        String result = words.stream()
                .filter(w -> w.length() > 1)
                .map(String::toUpperCase)
                .map(w -> w.substring(0, 1))
                .collect(Collectors.joining(" "));

        assertThat(result).isEqualTo("T H A N K");
    }
}
```

해당 예제 코드는 `Stream API`를 이용하여 기존이라면 for문을 이용한 loop문을 활용하여 지역변수가 사용되어 생기는 부수효과를 없애 순수함수로 만든 예제이다.