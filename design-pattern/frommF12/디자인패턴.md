## 디자인 패턴

객체지향 프로그래밍에서 프로그램을 설계할 때 객체 간의 상호관계 등을 이용한 패턴

[싱글톤 패턴](#싱글톤-패턴)  
[팩토리 패턴](#팩토리-패턴)  
[전략 패턴](#전략-패턴)  
[옵저버 패턴](#옵저버-패턴)  
[프록시 패턴과 프록시 서버](#프록시-패턴과-프록시-서버)  

## 싱글톤 패턴

생성 패턴 중 하나의 패턴으로 클래스당 하나의 인스턴스만 생성한다  

싱글톤을 구현하는 방법의 공통점  
1. 싱글톤으로 구현할 클래스의 생성자의 접근 제어자를 private 설정  
2. private static 멤버 변수 생성
3. 외부에서 싱글톤 인스턴스에 접근할 수 있도록 public static 메서드 제공 

private으로 제한해도 자바의 리플렉션을 이용하여 private 생성자에 접근하여 새로운 인스턴스를 생성할 수 있음  

enum으로 싱글톤 패턴을 구현하는 방법  
```
public enum Singleton {
  INSTANCE;
  
  private String title;
  
  public String getTitle() {
    return title;
  }
```

싱글톤 패턴을 써서 어디에 활용할까 ?  

의존성 주입(DI)

의존성 주입을 사용하기 전 싱글톤 패턴
```
public Class Computer {
  BenQMonitor monitor = BenQMonitor.getInstance();
  monitor.display();
}
```
computer 객체는 타입이 구체 클래스인 BenQMonitor에 의존하고 있음  
-> BenQMonitor가 아닌 다른 클래스로 변경한다면 인스턴스를 얻어오는 부분외에도 수많은 변경 발생될 수 있음
-> 객체간의 결합이 강하다  

의존성 주입을 사용한 싱글톤 패턴
```
public Class Computer {
  private Monitor monitor;
  
  public Computer(Monitor monitor) {
    this.monitor = monitor;
  }
  
   monitor.display();
```
인터페이스 Monitor 타입으로 주입받기 때문에 어떠한 클래스가 와도 상관이 없다  
-> 구체 클래스가 변경되어도 Computer 객체 입장에서는 상관이 없고, 알지도 못한다  
-> 객체간의 결합도를 낮춤

이게 싱글톤이랑 무슨 상관이 있는건데 ?  

객체에 주입되는 인스턴스는 오직 하나여도 실행에 지장이 없기 때문에 메모리를 아낄 수 있음  
싱글톤으로 관리되면 해당 인스턴스만 메모리에 존재하므로 프록시를 적용하기 효율적이다  

## 팩토리 패턴

객체 생성 부분을 떼어내 추상화한 패턴이다  

상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가진다   

상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없다  

-> 유연성을 가진다? 

## 전략 패턴

행위 패턴 중 하나로 정책 패턴이라고도 한다  

상황에 맞는 전략을 실행하는 패턴  

객체를 두 가지의 역할로 분담  

어떠한 실행 문맥이 있는 컨텍스트(Context)와 실행 문맥안에서 어떤 방식으로 실행할지 방법을 담고 있는 전략(Stategy)가 있음  

컨텍스트 안에서 전략을 바꿔가면서 애플리케이션을 진행한다  


## 옵저버 패턴

행위 패턴 중 하나이다  

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴  

주체 - 객체의 상태 변화를 보고 있는 관찰자  

옵저버 - 객체의 상태가 변경되면 그에 따라 추가적인 변경 사항이 발생되는 객체  


## 프록시 패턴과 프록시 서버

구조 패턴 중 하나이다  

클라이언트-서버 구조 

클라이언트 : 요청을 보내는 쪽  

서버 : 요청을 받고 응답을 보내는 쪽

클라이언트 <-> 서버 : 직접 호출 

클라이언트 <-> 대리자 <-> 서버 : 간접 호출 

간접호출은 서버(origin)와 직접 통신하는 것이 아닌 어떤 대리자를 통해서 통신하는 것

프록시라는 개념은 소프트,하드웨어 둘 다 존재한다  

프록시 객체의 개념은 대강 아래와 유사하다

원본 객체
```
public class Original {
  public void hello() {
    Sysmtem.out.println("hello");
  }
}
```

프록시 객체 
public class Proxy extends hello{

  private Original original;
  
  public void Proxy(Original original) {
     this.original = original;
  }
  
  @Override
  public void hello() {
    Sysmtem.out.println("proxy");
    original.hello();
    Sysmtem.out.println("proxy");
  }
}

