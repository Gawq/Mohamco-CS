## 디자인 패턴

객체지향 프로그래밍에서 프로그램을 설계할 때 객체 간의 상호관계 등을 이용한 패턴

[싱글톤 패턴](#싱글톤-패턴)  
[팩토리 패턴](#팩토리-패턴)  
[전략 패턴](#전략-패턴)  
[옵저버 패턴](#옵저버-패턴)  
[프록시 패턴과 프록시 서버](#프록시-패턴과-프록시-서버)  
[이터레이터 패턴](#이터레이터-패턴)
[노출모듈 패턴](#노출모듈-패턴)
[MVC 패턴](#MVC-패턴)
[MVP 패턴](#MVP-패턴)
[MVVM 패턴](MVVM-패턴)

## 싱글톤 패턴

생성 패턴 중 하나의 패턴으로 클래스당 하나의 인스턴스만 생성한다  

싱글톤을 구현하는 방법의 공통점  
1. 싱글톤으로 구현할 클래스의 생성자의 접근 제어자를 private 설정  
2. private static 멤버 변수 생성
3. 외부에서 싱글톤 인스턴스에 접근할 수 있도록 public static 메서드 제공 

private으로 제한해도 자바의 리플렉션을 이용하여 private 생성자에 접근하여 새로운 인스턴스를 생성할 수 있음  

enum으로 싱글톤 패턴을 구현하는 방법  
```
public enum Singleton {
  INSTANCE;
  
  private String title;
  
  public String getTitle() {
    return title;
  }
```

싱글톤 패턴을 써서 어디에 활용할까 ?  

의존성 주입(DI)

의존성 주입을 사용하기 전 싱글톤 패턴
```
public Class Computer {
  BenQMonitor monitor = BenQMonitor.getInstance();
  monitor.display();
}
```
computer 객체는 타입이 구체 클래스인 BenQMonitor에 의존하고 있음  
-> BenQMonitor가 아닌 다른 클래스로 변경한다면 인스턴스를 얻어오는 부분외에도 수많은 변경 발생될 수 있음
-> 객체간의 결합이 강하다  

의존성 주입을 사용한 싱글톤 패턴
```
public Class Computer {
  private Monitor monitor;
  
  public Computer(Monitor monitor) {
    this.monitor = monitor;
  }
  
   monitor.display();
```
인터페이스 Monitor 타입으로 주입받기 때문에 어떠한 클래스가 와도 상관이 없다  
-> 구체 클래스가 변경되어도 Computer 객체 입장에서는 상관이 없고, 알지도 못한다  
-> 객체간의 결합도를 낮춤

이게 싱글톤이랑 무슨 상관이 있는건데 ?  

객체에 주입되는 인스턴스는 오직 하나여도 실행에 지장이 없기 때문에 메모리를 아낄 수 있음  
싱글톤으로 관리되면 해당 인스턴스만 메모리에 존재하므로 프록시를 적용하기 효율적이다  

## 팩토리 패턴

객체 생성 부분을 떼어내 추상화한 패턴이다  

상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다

상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가진다   

상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없다  

-> 유연성을 가진다? 

## 전략 패턴

행위 패턴 중 하나로 정책 패턴이라고도 한다  

상황에 맞는 전략을 실행하는 패턴  

객체를 두 가지의 역할로 분담  

어떠한 실행 문맥이 있는 컨텍스트(Context)와 실행 문맥안에서 어떤 방식으로 실행할지 방법을 담고 있는 전략(Stategy)가 있음  

컨텍스트 안에서 전략을 바꿔가면서 애플리케이션을 진행한다  


## 옵저버 패턴

행위 패턴 중 하나이다  

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴  

주체 - 객체의 상태 변화를 보고 있는 관찰자  

옵저버 - 객체의 상태가 변경되면 그에 따라 추가적인 변경 사항이 발생되는 객체  


## 프록시 패턴과 프록시 서버

구조 패턴 중 하나이다  

클라이언트-서버 구조 

클라이언트 : 요청을 보내는 쪽  

서버 : 요청을 받고 응답을 보내는 쪽

클라이언트 <-> 서버 : 직접 호출 

클라이언트 <-> 대리자 <-> 서버 : 간접 호출 

간접호출은 서버(origin)와 직접 통신하는 것이 아닌 어떤 대리자를 통해서 통신하는 것

프록시라는 개념은 소프트,하드웨어 둘 다 존재한다  

프록시 객체의 개념은 대강 아래와 유사하다

원본 객체
```
public class Original {
  public void hello() {
    Sysmtem.out.println("hello");
  }
}
```

프록시 객체   
```
public class Proxy extends hello{

  private Original original;
  
  public void Proxy(Original original) {
     this.original = original;
  }
  
  @Override
  public void hello() {
    Sysmtem.out.println("proxy");
    original.hello();
    Sysmtem.out.println("proxy");
  }
}
```

## 이터레이터 패턴

이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
어떤 자료구조든지 이터레이터로 순회할 수 있다
이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체

## 노출모듈 패턴

즉시 실행 함수를 통해 접근 제어자를 만드는 패턴
자바스크립트는 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다
따라서 노출모듈 패턴을 통해 private과 public 접근 제어자를 구현한다

## MVC 패턴

애플리케이션의 컴포넌트를 모델, 뷰, 컨트롤러로 분리한 디자인 패턴
모델 : 데이터
뷰 : 레이아웃과 화면
컨트롤러 : 요청을 받아 모델과 뷰를 적절하게 제어한 뒤 응답

사용자가 장바구니에 담기 버튼 클릭 -> 컨트롤러 요청 수신 -> 비즈니스 로직 -> 장바구니 데이터 변경(모델) -> 뷰 처리 -> 응답

MVC를 활용한 방식으로 모델 1 모델 2가 있다

모델 1 : 비즈니스 로직과 뷰 영역을 같이 구현한 방식 (JSP에 몽땅 담아 처리하는 방식)
모델 2 : 비즈니스 로직 영역과 뷰 영역을 분리한 방식

스프링 MVC는 FrontController 패턴을 사용하여 MVC 패턴을 구현했다

DispatcherServlet이 모든 요청을 받고, 컨트롤러를 매핑해 비즈니스 로직을 실행시킨 뒤 클라이언트에게 응답한다

모델 2와 달리 모든 요청을 하나의 컨트롤러(DispatcherServlet이)받기 때문에 공통 로직 처리 등이 가능하다

## MVP 패턴

MVC 패턴으로부터 파생된 패턴이다
컨트롤러가 Presenter로 교체된 패턴이다
뷰와 프레젠터가 일대일 관계를 갖는다

## MVVM 패턴

MVC 패턴으로부터 파생된 패턴이다
컨트롤러가 뷰 모델로 바뀐 패턴이다
뷰 모델은 뷰를 추상화한 계층으로, MVC 패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다

